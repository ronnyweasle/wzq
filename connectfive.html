<html>
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>
    </title>
  </head>
  <body bgcolor="#000000" onload="javascript: paintBoard();">
    <canvas id="board" 
    style="z-index: 1;
position:absolute;
left:0px;
top:0px;
" >
  This text is displayed if your browser does not support HTML5 Canvas.
    </canvas>
    <canvas id="pieces" 
    style="z-index: 2;
position:absolute;
left:0px;
top:0px;
" >
  This text is displayed if your browser does not support HTML5 Canvas.
    </canvas>
    <canvas id="overlay" 
    style="z-index: 3;
position:absolute;
left:0px;
top:0px;    
" onclick="javascript: clickHandler(event);">
  This text is displayed if your browser does not support HTML5 Canvas.
    </canvas>
    <script>
      var xBoard = 0;
      var oBoard = 0;
      var begin = false;
      var pieceContext;
      var boardwidth, boardheight;
      var offset;
      var inc;
      var black = 'black';
      var white = 'white';
      var first = black;
      var moves = new Array();
      var printStack = new Array();
      var pieceStack = new Array();
      var printStep = -1;
      var pieceCount = 0;
      var curPiece = -1;
      var boardArray;
      var done = false;
      var octx = document.getElementById("overlay").getContext('2d');
      var overlay = document.getElementById("overlay");
      var boardSize = 19;
      var translation;
      function refreshButtons(){
        if (printStep == 0){
          document.getElementById('undo').disabled = true;
          document.getElementById('undoAll').disabled = true;
        }
        else{
          document.getElementById('undo').disabled = false;
          document.getElementById('undoAll').disabled = false;
        }
        if (printStep == printStack.length - 1){
          document.getElementById('redo').disabled = true;
          document.getElementById('redoAll').disabled = true;
        }
        else{
          document.getElementById('redo').disabled = false;
          document.getElementById('redoAll').disabled = false;
        }
      }



function initialize(){
	  xBoard = 0;
      oBoard = 0;
      begin = false;
    
      black = 'black';
      white = 'white';
      first = black;
      moves = new Array();
      printStack = new Array();
      pieceStack = new Array();
      printStep = -1;
      pieceCount = 0;
      curPiece = -1;
      boardArray;
      done = false;
      octx = document.getElementById("overlay").getContext('2d');
      overlay = document.getElementById("overlay");
      boardSize = 19;
      
}
      function paintBoard() {
      	initialize();
        flip = true;
        boardArray = new Array(boardSize);
        for (var i = 0; i < boardSize; i++) {
          boardArray[i] = new Array(boardSize);
        }
        moves = new Array();
        printStack = new Array();
        printStep = -1;
        var canvas = document.getElementById("pieces");
        var boardcanvas = document.getElementById("board");
        pieceContext = canvas.getContext('2d');
        pieceContext.clearRect(0, 0, canvas.width,canvas.height);
        boardCon = boardcanvas.getContext('2d');
        pieceContext.globalAlpha = 1;
        if (canvas.width  < window.innerWidth)
        {
          canvas.width  = window.innerWidth;
         
        }
        if (canvas.height < window.innerHeight)
        {
          canvas.height = window.innerHeight;
         
        }
        boardwidth = Math.min(canvas.height, canvas.width);
        boardheight = boardwidth;
        overlay.height = canvas.height;
        overlay.width = canvas.width;
        boardcanvas.width = canvas.width;
        boardcanvas.height = canvas.height;


        translation = (canvas.width - boardwidth)/2;

        boardCon.fillStyle = "#F6CC78";
        //boardCon.fillRect(0,0,canvas.width,canvas.height);
        var tweak = 10;
        
         inc = Math.floor(boardheight / (((boardSize-1) + (boardSize-1)/tweak)));
         
         offset = Math.floor( (boardwidth - (boardSize - 1) * inc) / 2 );

         var magic = offset*0.4;
        boardCon.fillRect(translation + magic, magic, boardwidth - 2*magic,boardwidth - 2*magic);
       
        boardCon.beginPath();
        boardCon.strokeStyle = 'black';
       
        
        boardCon.lineWidth = 2;
        for (var i = 0; i < boardSize; i++) {
          boardCon.moveTo(translation+offset + inc * i, offset);
          boardCon.lineTo(translation+offset + inc * i, boardheight - offset);
          boardCon.moveTo(translation+offset, offset + inc * i);
          boardCon.lineTo(translation+boardheight - offset, offset + inc * i);
        }
        boardCon.stroke();
        boardCon.closePath();
        var dotOff = offset + (boardSize - 1)/6 * inc;
        var dotInc = (boardSize - 1)/3 * inc;
        for (var i = 0 ; i < (boardSize-1)/2; i++){
          var x = Math.floor(i / ((boardSize-1)/6));
          var y = i % ((boardSize-1)/6);
          paintBoardDot(boardCon, translation+dotOff + x * dotInc, dotOff + y * dotInc, 'black');
        }

        printPush(-1, -1, null);
        pushMemBoard(-1, -1, null);
        refreshButtons();

      }
      function stroke(begin, end, dir, colour){
        var first;
        var second;
        var first = (begin.x < end.x || begin.y < end.y) ? begin : end;
        var second = (first == begin) ? end : begin;
        pieceContext.beginPath();
        pieceContext.strokeStyle = 'red';
        pieceContext.lineWidth   = inc*0.1;
        pieceContext.moveTo(first.x*inc + offset, first.y*inc + offset);
        pieceContext.lineTo(second.x*inc + offset, second.y*inc + offset);
        pieceContext.stroke();
        pieceContext.closePath();
      }
      function circle(ctx, begin, end, dir, colour){
        ctx.beginPath();
        ctx.strokeStyle = 'red';
        ctx.lineWidth   = inc*0.1;
        var rad = inc*0.55;
        var pythInc = Math.floor(rad/Math.sqrt(2));
        if (dir == "ver"){
          var top = (begin.y < end.y) ? begin : end;
          var bottom = (begin.y < end.y) ? end: begin;
          ctx.arc(offset + top.x * inc + translation, offset + inc*top.y, rad , 0, Math.PI, true);
          ctx.moveTo(offset + inc*bottom.x + rad+ translation, offset + inc*bottom.y);
          ctx.arc(offset + inc*bottom.x+ translation, offset + inc*bottom.y, rad , 0, Math.PI, false);
          ctx.moveTo(offset + top.x * inc - rad+ translation, offset + inc*top.y);
          ctx.lineTo(offset + inc*bottom.x - rad+ translation, offset + inc*bottom.y);
          ctx.moveTo(offset + top.x * inc + rad+ translation, offset + inc*top.y);
          ctx.lineTo(offset + inc*bottom.x + rad+ translation, offset + inc*bottom.y);
        }
        else if (dir == "hor"){
          var left = (begin.x < end.x) ? begin : end;
          var right = (begin.x < end.x) ? end: begin;
          ctx.arc(offset + inc*left.x+ translation, offset + inc*left.y, rad, Math.PI/2, Math.PI*3/2, false);
          ctx.moveTo(offset + inc*right.x+ translation, offset + inc*right.y + rad);
          ctx.arc(offset + inc*right.x+ translation, offset + inc*right.y, rad, Math.PI/2, Math.PI*3/2, true);
          ctx.moveTo(offset + inc*left.x+ translation, offset + inc*left.y - rad);
          ctx.lineTo(offset + inc*right.x+ translation, offset + inc*right.y - rad);
          ctx.moveTo(offset + inc*left.x+ translation, offset + inc*left.y + rad);
          ctx.lineTo(offset + inc*right.x+ translation, offset + inc*right.y + rad);
        }
        else if (dir == "up"){
          rad = rad-1;
          var left = (begin.x < end.x) ? begin : end;
          var right = (begin.x < end.x) ? end: begin;
          ctx.arc(offset + inc*left.x+ translation, offset + inc*left.y, rad, Math.PI/4, Math.PI*5/4,  false);
          ctx.moveTo(offset + inc*right.x + pythInc+ translation, offset + inc*right.y + pythInc);
          ctx.arc(offset + inc*right.x+ translation, offset + inc*right.y, rad, Math.PI/4, Math.PI*5/4, true);
          ctx.moveTo(offset + inc*left.x - pythInc+ translation, offset + inc*left.y - pythInc);
          ctx.lineTo(offset + inc*right.x - pythInc+ translation, offset + inc*right.y - pythInc);
          ctx.moveTo(offset + inc*left.x + pythInc+ translation, offset + inc*left.y + pythInc);
          ctx.lineTo(offset + inc*right.x + pythInc+ translation, offset + inc*right.y + pythInc);
        }
        else if (dir == "down"){
          rad = rad-1;
          var left = (begin.x < end.x) ? begin : end;
          var right = (begin.x < end.x) ? end: begin;
          ctx.arc(offset + inc*left.x+ translation, offset + inc*left.y, rad, Math.PI*3/4, Math.PI*7/4,  false);
          ctx.moveTo(offset + inc*right.x - pythInc+ translation, offset + inc*right.y + pythInc);
          ctx.arc(offset + inc*right.x+ translation, offset + inc*right.y, rad, Math.PI*3/4, Math.PI*7/4, true);
          ctx.moveTo(offset + inc*left.x - pythInc+ translation, offset + inc*left.y + pythInc);
          ctx.lineTo(offset + inc*right.x - pythInc+ translation, offset + inc*right.y + pythInc);
          ctx.moveTo(offset + inc*left.x + pythInc+ translation, offset + inc*left.y - pythInc);
          ctx.lineTo(offset + inc*right.x + pythInc+ translation, offset + inc*right.y - pythInc);
        }
        ctx.stroke();
        ctx.closePath();
      }
      function circleWinner(ctx, x, y, colour){
        done = true;
        //alert(colour+" won!");
        ctx.strokeStyle = colour;
        var dirs = ["up", "down", "hor", "ver"];
        for (var i = dirs.length - 1; i >= 0; i--) {
          curDir = boardArray[x][y][dirs[i]];
          if (curDir.length >= 5){
            circle(pieceContext, curDir.begin, curDir.end, dirs[i], colour);
          }
        }
        ;
      }
      function paintBoardDot(boardCon, x, y, colour){
        boardCon.beginPath();
        boardCon.strokeStyle = colour;
        boardCon.lineWidth   = inc*0.01;
        boardCon.arc(x, y, inc*0.15 , 0, Math.PI * 2, true);
        boardCon.stroke();
        boardCon.fillStyle = colour;
        boardCon.fill();
        boardCon.closePath();
      }
      function markLastMove(ctx){
        var a = (pieceStack[curPiece].colour == 'black')? 'white' : 'black';
        //alert(a);
        ctx.fillStyle = a;
        ctx.font = "bold " + inc*0.5 +"px SimSun";
        ctx.textAlign="center"; 
        ctx.fillText("五", pieceStack[curPiece].x*inc + offset + translation, pieceStack[curPiece].y*inc + offset + inc*0.15);
       // paintPiece(pieceStack[curPiece].x*inc + offset, pieceStack[curPiece].y*inc + offset, a, false);
        if (curPiece-1 <= 0) return;
        var revert = pieceStack[curPiece-1].colour;
        paintPiece(ctx, pieceStack[curPiece-1].x*inc + offset + translation, pieceStack[curPiece-1].y*inc + offset, revert, true);
         ctx.fillStyle = revert;
          //context.fillText("伍", pieceStack[curPiece-1].x*inc + offset, pieceStack[curPiece-1].y*inc + offset+inc*0.1);

      }
      function pushMemBoard(x,y, colour){
        if (pieceCount >= 0){
        	if (curPiece < pieceCount && curPiece > -1){
        	  for (var i = 0; i < pieceCount-curPiece; i++) pieceStack.pop();
           
         	 pieceCount = curPiece;
    	  }

          pieceStack.push({'x':x, 'y':y, 'colour': colour}
                         );
          curPiece++;


          
        }
      }
      function printPush(x, y, colour) {
        printStep++;
        if (printStep < printStack.length) {
        	var len = printStack.length;
        	for (var i = 0; i < len-printStep; i++){
        	 printStack.pop();

        	}

        }
        printStack.push(document.getElementById('pieces').toDataURL());
      
      }
      function placePiece(x, y, colour){
        boardArray[x][y] = {
        }
          ;
        cur = boardArray[x][y];
        cur["up"] = {
          'colour': colour, 'length': 1, 'begin' : {'x' : x, 'y' : y}
          , 'end' : {'x' : x, 'y' : y}
        }
          ;
        cur["down"] = {
          'colour': colour, 'length': 1, 'begin' : {'x' : x, 'y' : y}
          , 'end' : {'x' : x, 'y' : y}
        }
          ;
        cur["hor"] = {
          'colour': colour, 'length': 1, 'begin' : {'x' : x, 'y' : y}
          , 'end' : {'x' : x, 'y' : y}
        }
          ;
        cur["ver"] = {
          'colour': colour, 'length': 1, 'begin' : {'x' : x, 'y' : y}
          , 'end' : {'x' : x, 'y' : y}
        }
          ;
        var res = "";

        res = res + checkAndJoin(x, y, colour, x-1, y-1, x+1, y+1);
        res = res + checkAndJoin(x, y, colour, x-1, y, x+1, y);
        res = res + checkAndJoin(x, y, colour, x-1, y+1, x+1, y-1);
        res = res + checkAndJoin(x, y, colour, x, y-1, x, y+1);
        //if (res != "") alert(res);

        checkWin(x, y, colour);
      }
      function unplace(x, y, colour){
        // alert("unsetting"+ x + "," + y);
        boardArray[x][y] = undefined;
        //down
        checkAndSever(x, y, colour, x-1, y-1, x+1, y+1);
        //hor
        checkAndSever(x, y, colour, x-1, y, x+1, y);
        //up
        checkAndSever(x, y, colour, x-1, y+1, x+1, y-1);
        //ver
        checkAndSever(x, y, colour, x, y-1, x, y+1);
      }
      function checkAndSever(x, y, colour, x1, y1, x2, y2){
        var type;
        if (x1 < x2 && y1 < y2) type = 'down';
        if (x1 < x2 && y1 > y2) type = 'up';
        if (y1 == y2) type = 'hor';
        if (x1 == x2) type = 'ver';
        var a;
        var b;
        if (type == 'down'){
          a = 1;
          b = 1;
        }
        else if (type == 'up'){
          a = 1;
          b = -1;
        }
        else if (type == 'hor'){
          a = 1;
          b = 0;
        }
        else{
          a = 0;
          b = 1;
        }
        var fore = (inRange(x2) && inRange(y2)) ? boardArray[x2][y2] : undefined;
        var aft = (inRange(x1) && inRange(y1)) ? boardArray[x1][y1] : undefined;
        var newlen = 0;
        if (fore != undefined && aft != undefined) {
          if (fore[type].colour == colour && aft[type].colour == colour){
            newforelen = Math.max(Math.abs(x-fore[type].end.x), Math.abs(y-fore[type].end.y));
            newaftlen = Math.max(Math.abs(x-aft[type].begin.x), Math.abs(y-aft[type].begin.y));
            markRest(x,y, x2, y2, newforelen, newforelen, type, {'x' : x+a, 'y' : y+b}
                     , fore[type].end);
            markRest(x,y, x1, y1, newaftlen, newaftlen, type, aft[type].begin, {'x' : x-a, 'y' : y-b}
                    );
            return;
          }
        }
        if (fore != undefined && fore[type].colour == colour){
          newforelen = Math.max(Math.abs(x-fore[type].end.x), Math.abs(y-fore[type].end.y));
          markRest(x,y, x2, y2, newforelen, newforelen, type, {'x' : x+a, 'y' : y+b}
                   , fore[type].end);
          //   alert("forelen: "+newforelen);
          return;
        }
        if (aft != undefined && aft[type].colour == colour){
          newaftlen = Math.max(Math.abs(x-aft[type].begin.x), Math.abs(y-aft[type].begin.y));
          markRest(x,y, x1, y1, newaftlen, newaftlen, type, aft[type].begin, {'x' : x-a, 'y' : y-b}
                  );
          // alert("aftlen: "+newaftlen);
          return;
        }
      }
      function undo(myctx) {
        document.getElementById('undo').disabled = true;
        if (printStep > 0) {
          printStep--;
          //    alert(curPiece);
          var x = pieceStack[curPiece].x;
          var y = pieceStack[curPiece].y;
          var c = pieceStack[curPiece].colour;
          curPiece--;
         // alert(curPiece + " " + printStep);

          
          //   alert(c);
           
          unplace(x, y, c);

          done = false;
          flip = !flip;
          var canvasPic = new Image();
          canvasPic.src = printStack[printStep];
          canvasPic.onload = function () {
          	myctx.clearRect(0, 0, overlay.width, overlay.height);
            myctx.drawImage(canvasPic, 0, 0);

          }
            
        }
        refreshButtons();
      }
      function redo(ctx) {
        document.getElementById('redo').disabled = true;
        if (printStep < printStack.length-1) {
          printStep++;
          curPiece++;
          var x = pieceStack[curPiece].x;
          var y = pieceStack[curPiece].y;
          var c = pieceStack[curPiece].colour;
          placePiece(x, y, c);
          flip = !flip;
          var canvasPic = new Image();
          canvasPic.src = printStack[printStep];
          canvasPic.onload = function () {
            ctx.drawImage(canvasPic, 0, 0);
          }
        }
        refreshButtons();
        
      }
      function paintPiece(ctx, x, y, colour, solid){
        ctx.beginPath();
        ctx.strokeStyle = colour;
        ctx.lineWidth   = 3;
        var r = inc*0.4;
        ctx.fillStyle = colour;
        if (!solid) {
          ctx.arc(x, y, r , 0, Math.PI * 2, true);
          ctx.strokeStyle = colour;
          ctx.stroke();
        }
        if (solid){
          ctx.arc(x, y, r+2 , 0, Math.PI * 2, true);
          ctx.fill();
        }
        ctx.closePath();
      }
      function paintOverlay(octx, ox, oy, x, y, colour){
        octx.clearRect(0, 0, overlay.width, overlay.height);
        if (boardArray[ox][oy] != undefined || !inRange(ox) || !inRange(oy)) return;
        octx.beginPath();
        octx.globalAlpha = 0.5;
        var r = inc*0.4;
        octx.fillStyle = colour;
        octx.arc(x, y, r+2 , 0, Math.PI * 2, true);
        octx.fill();
        octx.closePath();
      }
      function pushAndRefresh(x, y, colour){
        printPush(x, y, colour);
        refreshButtons();
      }
      var flip = true;
      function markRest(x0, y0, x1, y1, rowlen,len, type, begin, end){
        var dir;
        var a;
        var b;
        if (type == 'down'){
          if (x0 > x1){
            a = -1;
            b = -1;
          }
          else{
            a = 1;
            b = 1;
          }
        }
        else if (type == 'up'){
          if (x0 > x1){
            a = -1;
            b = 1;
          }
          else{
            a = 1;
            b = -1;
          }
        }
        else if (type == 'hor'){
          if (x0 > x1){
            a = -1;
            b = 0;
          }
          else{
            a = 1;
            b = 0;
          }
        }
        else{
          if (y0 > y1){
            a = 0;
            b = -1;
          }
          else{
            a = 0;
            b = 1;
          }
        }
        for (var i = 0; i < rowlen; i++) {
          var c = boardArray[x1+a*i][y1+b*i][type];
          // alert(c);
          // alert(x1+a*i ) ;
          // alert(y1+b*i);
          c.length = len;
          c.begin = begin;
          c.end = end;
        }
        ;
      }
      function inRange(k){
        return k >= 0 && k < boardSize;
      }
      function checkAndJoin(x, y, colour, x1, y1, x2, y2){

        var type;
        if (x1 < x2 && y1 < y2) type = 'down';
        if (x1 < x2 && y1 > y2) type = 'up';
        if (y1 == y2) type = 'hor';
        if (x1 == x2) type = 'ver';

        var cur = (inRange(x) && inRange(y)) ? boardArray[x][y] : undefined;
        var fore = (inRange(x1) && inRange(y1)) ?  boardArray[x1][y1] : undefined;
        var aft = (inRange(x2) && inRange(y2)) ? boardArray[x2][y2] : undefined;

        var newlen = 0;

        if (fore != undefined && aft != undefined) {
          if (fore[type].colour == colour && aft[type].colour == colour){
            newlen = fore[type].length + aft[type].length + 1;
            cur[type].begin.x = fore[type].begin.x;
            cur[type].end.x = aft[type].end.x;
            cur[type].begin.y = fore[type].begin.y;
            cur[type].end.y = aft[type].end.y;
            cur[type].length = newlen;
            markRest(x,y, x1, y1, fore[type].length, newlen, type, cur[type].begin, cur[type].end);
            markRest(x,y, x2, y2, aft[type].length, newlen, type, cur[type].begin, cur[type].end);
            return (newlen + " " + type);
          }
        }
        if (fore != undefined && fore[type].colour == colour){
          newlen = fore[type].length + 1;
          cur[type].begin.x = fore[type].begin.x;
          cur[type].begin.y = fore[type].begin.y;
          cur[type].length = newlen;
          markRest(x,y, x1, y1, fore[type].length, newlen, type, cur[type].begin, cur[type].end);
          return (newlen + " " + type);
        }
        if (aft != undefined && aft[type].colour == colour){
          newlen = aft[type].length + 1;
          cur[type].end.x = aft[type].end.x;
          cur[type].end.y = aft[type].end.y;
          cur[type].length = newlen;
          markRest(x,y, x2, y2, aft[type].length, newlen, type, cur[type].begin, cur[type].end);
          return (newlen + " " + type);
        }
        //alert(type + (fore != undefined) + fore[type].colour + colour);
        return "";
      }
      function checkWin(x, y, colour){
        if (boardArray[x][y]["up"].length >= 5 ||
            boardArray[x][y]["down"].length >= 5 || 
            boardArray[x][y]["hor"].length >= 5 ||
            boardArray[x][y]["ver"].length >= 5 ){
          //alert(colour + " wins!");
          circleWinner(pieceContext, x, y, colour);
          // paintBoard();
        }
      }
      function clickHandler(e) {
     
        var dsocleft=document.all? iebody.scrollLeft : pageXOffset
        var dsoctop=document.all? iebody.scrollTop : pageYOffset
        var y = Math.round((e.clientY + dsoctop - offset)/inc);
        var x =  Math.round((e.clientX + dsocleft - offset - translation)/inc);
        var paintX = x*inc + offset + translation;
        var paintY = y*inc + offset;
          
        if (paintX > boardwidth + translation || paintY > boardwidth) return;

          
        if (done) {
          // paintBoard();
          // done = false;
          return;
        }
        if (boardArray[x][y] != undefined) return;

        var c;
        if (flip){
          c = first;
        }
        else{
          c = (first == black) ? white: black;
        }
        flip = !flip;
        paintPiece(pieceContext, paintX, paintY, c, true, false);

        placePiece(x, y, c);

        pushMemBoard(x, y, c);

        markLastMove(pieceContext);
        pushAndRefresh(x, y, c);
        pieceCount++;
        //alert("piececount is " + pieceCount);
      }
      window.onmousemove = handleMouseMove;

      function undoAll(ctx){
      	while(printStep > 0){
      		undo(ctx);
      	}
      }
      function redoAll(ctx){
      	while(printStep < printStack.length-1){
      		redo(ctx);
      	}
      }
      function handleMouseMove(event) {
        event = event || window.event;
        
        // event.clientX and event.clientY contain the mouse position
        var dsocleft=document.all? iebody.scrollLeft : pageXOffset
        var dsoctop=document.all? iebody.scrollTop : pageYOffset
        var y = Math.round((event.clientY + dsoctop - offset)/inc);
        var x =  Math.round((event.clientX + dsocleft - offset - translation)/inc);

        var paintX = x*inc + offset + translation;
        var paintY = y*inc + offset;
        if (paintX > boardwidth + translation || paintY > boardwidth) return;
        var colour;
        if (curPiece < 0) colour = first;
        else{
          colour = pieceStack[curPiece].colour;
          colour = (colour == black) ? white : black;
        }
        // function paintPiece(x, y, colour, solid, extra){
        paintOverlay(octx, x, y, paintX, paintY, colour );
      }
    </script>
    <input id="undo" style="z-index:10;position:relative;" type="button" value="undo" onclick="undo(pieceContext);" />
    <input id="undoAll" style="z-index:10;position:relative;" type="button" value="undoAll" onclick="undoAll(pieceContext);" />
    <input id="redoAll" style="z-index:10;position:relative;" type="button" value="redoAll" onclick="redoAll(pieceContext);" />
    <input id="redo" style="z-index:10;position:relative;" type="button" value="redo" onclick="redo(pieceContext);" />
    <input id="reset" style="z-index:10;position:relative;" type="button" value="reset" onclick="paintBoard();" />
  </body>
</html>